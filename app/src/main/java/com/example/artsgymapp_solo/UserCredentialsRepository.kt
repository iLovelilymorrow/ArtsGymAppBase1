package com.example.artsgymapp_solo

import android.content.Context
import android.util.Log // For logging, especially if you implement more complex hashing later
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.emptyPreferences
import androidx.datastore.preferences.core.stringPreferencesKey
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import java.io.IOException

// Assumes AppSettingsDataStore.kt is in this package or imported

class UserCredentialsRepository(private val context: Context) {

    private val dataStore = context.appSettingsDataStore

    private object PreferencesKeys {
        val USERNAME = stringPreferencesKey("username")
        // NOTE: Currently, this key will store plain text passwords.
        // For secure hashing, it should store the generated HASH.
        val PASSWORD = stringPreferencesKey("password_plaintext_or_hash") // Renamed for clarity on current/future state
    }

    companion object {
        const val DEFAULT_ADMIN_USERNAME = "admin"

        // WARNING: Storing plain text passwords, even defaults, is insecure.
        // FOR TESTING/LEARNING ONLY.
        // If implementing hashing, this should be:
        // const val DEFAULT_PASSWORD_HASH = "your_pre_computed_secure_hash_of_default_password"
        const val DEFAULT_PLAIN_TEXT_PASSWORD = "pass"
    }

    val adminUsernameFlow: Flow<String> = dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(emptyPreferences())
            } else {
                throw exception
            }
        }.map { preferences ->
            preferences[PreferencesKeys.USERNAME] ?: DEFAULT_ADMIN_USERNAME
        }

    // This flow currently emits plain text passwords.
    // If hashing is implemented, it should emit the stored HASH.
    // The name "passwordHashFlow" can be kept if the intent is for it to eventually hold hashes.
    val adminPasswordPlainTextFlow: Flow<String> = dataStore.data // Renamed from passwordHashFlow for clarity in plain text mode
        .catch { exception ->
            if (exception is IOException) {
                emit(emptyPreferences())
            } else {
                throw exception
            }
        }.map { preferences ->
            // If hashing is implemented, this should be:
            // preferences[PreferencesKeys.PASSWORD] ?: DEFAULT_PASSWORD_HASH
            preferences[PreferencesKeys.PASSWORD] ?: DEFAULT_PLAIN_TEXT_PASSWORD
        }

    // This function currently receives and stores a plain text password.
    // For secure hashing, the 'password' parameter here should ideally be the
    // HASHED password, generated by the ViewModel before calling this function.
    suspend fun updateCredentials(username: String, plainTextPasswordToStore: String) {
        // === IF IMPLEMENTING HASHING, THE VIEWMODEL SHOULD DO THIS ===
        // 1. val hashedPassword = hashPassword(plainTextPasswordToStore) // Call the secure hashPassword function
        // 2. dataStore.edit { preferences ->
        // 3.     preferences[PreferencesKeys.USERNAME] = username
        // 4.     preferences[PreferencesKeys.PASSWORD] = hashedPassword // Store the HASH
        // 5. }
        // =============================================================

        // CURRENT PLAIN TEXT IMPLEMENTATION (INSECURE):
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.USERNAME] = username
            preferences[PreferencesKeys.PASSWORD] = plainTextPasswordToStore // Storing plain text
        }
    }

    // --- Password Hashing (Placeholder - IMPORTANT: Implement securely if not using plain text) ---

    /**
     * WARNING: THIS IS AN INSECURE PLACEHOLDER FOR HASHING.
     * If you are NOT using plain text passwords, replace this with a strong hashing algorithm
     * like BCrypt, SCrypt, or Argon2.
     *
     * If you keep plain text passwords, this function is used by verifyPassword
     * but its output isn't what's truly stored if updateCredentials saves plain text.
     *
     * @param password The plain text password.
     * @return A "hashed" (currently trivial transformation) or plain text representation.
     */
    fun hashPassword(password: String): String {
        // === IF IMPLEMENTING SECURE HASHING (e.g., BCrypt) ===
        // 1. Add BCrypt library dependency (e.g., org.mindrot:jbcrypt:0.4)
        // 2. Import org.mindrot.jbcrypt.BCrypt
        // 3. if (password.isEmpty()) return ""
        // 4. return BCrypt.hashpw(password, BCrypt.gensalt(12)) // 12 is a common cost factor
        // =======================================================

        // CURRENT PLACEHOLDER (INSECURE / effectively unused if storing plain text directly):
        // If you store plain text via updateCredentials, this function is only relevant
        // for the verifyPassword logic below, which would be comparing a transformation
        // of the entered password with the directly stored plain text password.
        // For true plain text comparison, verifyPassword should just do a direct string equals.
        Log.w("UserCredentialsRepo", "Using insecure placeholder hashPassword method.")
        if (password.isEmpty()) {
            return ""
        }
        // This is NOT a hash. It's just a reversible transformation for placeholder purposes.
        return "demo_transform_${password.reversed()}_suffix"
    }

/**
 * Verifies a plain text password against the stored password (currently plain text).
 *
 * WARNING: THIS IS CURRENTLY SET UP FOR INSECURE PLAIN TEXT COMPARISON OR
 *          COMPARISON WITH THE OUTPUT OF THE INSECURE `hashPassword` PLACEHOLDER.
 *
 * @param enteredPassword The plain text password entered by the user.
 * @param storedPassword  The password retrieved from DataStore (currently plain text).
 * @return True if they "match".
 */

fun verifyPassword(enteredPassword: String, storedPassword: String): Boolean {
    // === IF IMPLEMENTING SECURE HASHING (e.g., BCrypt) ===
    // `storedPassword` parameter would actually be `storedHash`
    // 1. if (enteredPassword.isEmpty() || storedHash.isEmpty()) return false
    // 2. try {
    // 3.   return BCrypt.checkpw(enteredPassword, storedHash)
    // 4. } catch (e: Exception) { // Catch potential errors if storedHash is not valid BCrypt
    // 5.   Log.e("UserCredentialsRepo", "Error verifying password with BCrypt", e)
    // 6.   return false
    // 7. }
    // ========================================================

    // CURRENT PLAIN TEXT IMPLEMENTATION:
    // For a direct plain text comparison, it should simply be:
    // return enteredPassword == storedPassword

    // However, to make it work with the current placeholder `hashPassword`
    // and assuming `updateCredentials` stores plain text:
    // We are comparing the "transformed" entered password with the plain text stored password.
    // This is inconsistent and still insecure.
    // The most straightforward plain text verification:
    if (enteredPassword.isEmpty() || storedPassword.isEmpty()) {
        return false
    }
    // Direct comparison if you are truly storing and comparing plain text:
    val directMatch = enteredPassword == storedPassword
    Log.d("UserCredentialsRepo", "Plain text verification: entered='$enteredPassword', stored='$storedPassword', match=$directMatch")

    // If you were to use the demo_transform for some reason (still insecure):
    // val transformedEnteredPassword = hashPassword(enteredPassword) // Uses the demo_transform
    // val matchWithTransform = transformedEnteredPassword == storedPassword
    // Log.d("UserCredentialsRepo", "Verification with demo_transform: transformedEntered='$transformedEnteredPassword', stored='$storedPassword', match=$matchWithTransform")
    // return matchWithTransform

    return directMatch // Simplest for pure plain text mode
 }
}